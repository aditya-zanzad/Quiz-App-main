import Quiz from "../models/Quiz.js";
import mongoose from "mongoose";
import {
  generateMCQ,
  generateTrueFalse,
  generateQuestionsFromParagraph,
} from "../services/aiQuestionGenerator.js";
import { validateQuestion } from "../services/contentQualityChecker.js";
import logger from "../utils/logger.js";

// ✅ General MCQ Generator
export const generateQuizQuestions = async (req, res) => {
    logger.info(`Generating ${req.body.numQuestions} ${req.body.questionType} questions for quiz ${req.params.id} on topic "${req.body.topic}"`);
    try {
        const { topic, numQuestions, questionType = "mcq" } = req.body;
        const { id } = req.params;

        if (!topic || !numQuestions) {
            logger.warn("Missing topic or numQuestions for AI question generation");
            return res
                .status(400)
                .json({ error: "Topic and number of questions are required" });
        }

        if (!mongoose.Types.ObjectId.isValid(id)) {
            logger.warn(`Invalid quiz ID for AI question generation: ${id}`);
            return res.status(400).json({ error: "Invalid quiz ID" });
        }

        const quiz = await Quiz.findById(id);
        if (!quiz) {
            logger.warn(`Quiz not found: ${id} for AI question generation`);
            return res.status(404).json({ error: "Quiz not found" });
        }

        const existingQuestions = new Set(
            quiz.questions.map((q) => q.question.trim().toLowerCase())
        );
        let finalQuestions = [];
        let parsed;

        if (questionType === "mcq") {
            parsed = await generateMCQ(topic, numQuestions);
        } else if (questionType === "true_false") {
            parsed = await generateTrueFalse(topic, numQuestions);
        } else {
            logger.warn(`Invalid question type for AI question generation: ${questionType}`);
            return res.status(400).json({ error: "Invalid question type" });
        }

        const newUnique = parsed.questions.filter((q) => {
            const normalized = q.question.trim().toLowerCase();
            return !existingQuestions.has(normalized) && validateQuestion(q);
        });

        newUnique.forEach((q) => {
            const normalized = q.question.trim().toLowerCase();
            if (!["easy", "medium", "hard"].includes(q.difficulty)) {
                q.difficulty = "medium";
            }
            existingQuestions.add(normalized);
        });

        finalQuestions.push(...newUnique);

        if (finalQuestions.length === 0) {
            logger.warn("No new unique questions could be generated by AI");
            return res
                .status(400)
                .json({ error: "No new unique questions could be generated" });
        }

        quiz.questions.push(...finalQuestions.slice(0, numQuestions));
        quiz.totalMarks = quiz.questions.length;
        quiz.passingMarks = Math.ceil(quiz.totalMarks / 2);
        quiz.duration = quiz.questions.length * 2;

        await quiz.save();
        logger.info(`Successfully added ${finalQuestions.length} new questions to quiz ${id}`);
        res.json({
            message: `${finalQuestions.length} new questions added successfully`,
            questions: finalQuestions.slice(0, numQuestions),
        });
    } catch (err) {
        logger.error({ message: "Error generating AI questions", error: err.message, stack: err.stack });
        res.status(500).json({ error: "Internal server error", details: err.message });
    }
};

// ✅ Adaptive MCQ Generator
export const generateAdaptiveQuestions = async (req, res) => {
    logger.info(`Generating ${req.body.numQuestions} adaptive questions for quiz ${req.body.quizId} based on performance: ${req.body.performance}`);
    try {
        const { performance, quizId, numQuestions = 5 } = req.body;

        const quiz = await Quiz.findById(quizId);
        if (!quiz) {
            logger.warn(`Quiz not found: ${quizId} for adaptive question generation`);
            return res.status(404).json({ error: "Quiz not found" });
        }

        const topic = quiz.category;
        const difficulty =
            performance === "low" ? "easy" : performance === "high" ? "hard" : "medium";

        const existingQuestions = new Set(
            quiz.questions.map((q) => q.question.trim().toLowerCase())
        );
        let finalQuestions = [];

        const parsed = await generateMCQ(topic, numQuestions, difficulty);

        const newUnique = parsed.questions.filter((q) => {
            const normalized = q.question.trim().toLowerCase();
            return !existingQuestions.has(normalized) && validateQuestion(q);
        });

        newUnique.forEach((q) => {
            const normalized = q.question.trim().toLowerCase();
            existingQuestions.add(normalized);
        });

        finalQuestions.push(...newUnique);

        if (finalQuestions.length === 0) {
            logger.warn("No new unique adaptive questions could be generated by AI");
            return res
                .status(400)
                .json({ error: "No new unique adaptive questions could be generated" });
        }

        quiz.questions.push(...finalQuestions.slice(0, numQuestions));
        quiz.totalMarks = quiz.questions.length;
        quiz.duration = quiz.questions.length * 2;
        quiz.passingMarks = Math.ceil(quiz.totalMarks / 2);

        await quiz.save();
        logger.info(`Successfully added ${finalQuestions.length} new adaptive questions to quiz ${quizId}`);
        res.json({
            message: `${finalQuestions.length} adaptive questions added successfully`,
            questions: finalQuestions.slice(0, numQuestions),
        });
    } catch (err) {
        logger.error({ message: "Error generating adaptive AI questions", error: err.message, stack: err.stack });
        res.status(500).json({ error: "Internal server error", details: err.message });
    }
};

// ✅ Generate questions from paragraph text
export const generateQuestionsFromText = async (req, res) => {
    logger.info(`Generating ${req.body.numQuestions} ${req.body.questionType} questions from paragraph text`);
    try {
        const { paragraph, numQuestions, questionType = "mcq", difficulty = "any" } = req.body;

        if (!paragraph || !numQuestions) {
            logger.warn("Missing paragraph or numQuestions for AI question generation from text");
            return res
                .status(400)
                .json({ error: "Paragraph text and number of questions are required" });
        }

        if (paragraph.length < 50) {
            logger.warn("Paragraph too short for meaningful question generation");
            return res
                .status(400)
                .json({ error: "Paragraph must be at least 50 characters long" });
        }

        if (numQuestions < 1 || numQuestions > 20) {
            logger.warn("Invalid number of questions requested");
            return res
                .status(400)
                .json({ error: "Number of questions must be between 1 and 20" });
        }

        const parsed = await generateQuestionsFromParagraph(paragraph, numQuestions, questionType, difficulty);

        // Validate generated questions
        const validQuestions = parsed.questions.filter(validateQuestion);

        if (validQuestions.length === 0) {
            logger.warn("No valid questions could be generated from the paragraph");
            return res
                .status(400)
                .json({ error: "No valid questions could be generated from the provided text" });
        }

        logger.info(`Successfully generated ${validQuestions.length} questions from paragraph text`);

        res.json({
            success: true,
            message: `${validQuestions.length} questions generated successfully`,
            questions: validQuestions,
            metadata: {
                originalParagraph: paragraph.substring(0, 100) + "...",
                questionType,
                difficulty,
                totalGenerated: validQuestions.length
            }
        });

    } catch (err) {
        logger.error({ message: "Error generating questions from paragraph", error: err.message, stack: err.stack });
        res.status(500).json({ error: "Internal server error", details: err.message });
    }
};
